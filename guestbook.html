<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Juan Tribaldos</title>
    <link rel="stylesheet" href="style.css">
    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; width: 100%; height: 100%; position: fixed; }
        
        /* Cursor de manita */
        #gbCanvas { 
            display: block; 
            cursor: grab; 
            touch-action: none; 
        }
        #gbCanvas:active {
            cursor: grabbing;
        }

        #mobileInput {
            position: absolute;
            opacity: 0;
            pointer-events: none;
            left: -100px;
            top: -100px;
        }
    </style>
</head>
<body>

    <input type="text" id="mobileInput" autocomplete="off" font-size="16px">
    <canvas id="gbCanvas"></canvas>
    
    <script src="nav.js"></script>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js";
    import { getDatabase, ref, set, onValue } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-database.js";

    const firebaseConfig = {
        apiKey: "AIzaSyBHo5KM-RwA4fa0XeM_y3P66xZ9AGrwRUE",
        authDomain: "guestbook-jt.firebaseapp.com",
        databaseURL: "https://guestbook-jt-default-rtdb.europe-west1.firebasedatabase.app",
        projectId: "guestbook-jt",
        storageBucket: "guestbook-jt.firebasestorage.app",
        messagingSenderId: "676074383664",
        appId: "1:676074383664:web:86f48f6f59508d8e3d9370"
    };

    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);
    const dbRef = ref(db, 'canvas_content');

    const FONT_SIZE = 13;
    const FONT_FACE = "'Times New Roman', Times, serif";
    
    class Guestbook {
        constructor() {
            this.canvas = document.getElementById("gbCanvas");
            this.ctx = this.canvas.getContext("2d");
            this.mobileInput = document.getElementById("mobileInput");
            
            this.content = {};
            this.offset = { x: 0, y: 0 };
            this.cursor = { x: 0, y: 0 };
            
            this.isDragging = false;
            this.lastMousePos = { x: 0, y: 0 };
            
            this.setupCanvas();
            this.initListeners();
            this.syncData();
        }

        setupCanvas() {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
            this.ctx.font = `${FONT_SIZE}px ${FONT_FACE}`;
            const metrics = this.ctx.measureText("M");
            this.cellW = metrics.width * 0.9;
            this.cellH = FONT_SIZE * 0.9;
            this.render();
        }

        syncData() {
            onValue(dbRef, (snapshot) => {
                this.content = snapshot.val() || {};
                this.render();
            });
        }

        initListeners() {
            window.addEventListener('resize', () => this.setupCanvas());

            // Variables para distinguir Tap de Drag
            let startX, startY;
            let isMoving = false;
            const MOVE_THRESHOLD = 6; 

            const startDrag = (x, y) => {
                this.isDragging = true;
                this.lastMousePos = { x, y };
                startX = x;
                startY = y;
                isMoving = false;
            };

            const moveDrag = (x, y) => {
                if (!this.isDragging) return;
                
                const dist = Math.hypot(x - startX, y - startY);
                if (dist > MOVE_THRESHOLD) isMoving = true;

                const dx = (x - this.lastMousePos.x) / this.cellW;
                const dy = (y - this.lastMousePos.y) / this.cellH;
                this.offset.x -= dx;
                this.offset.y -= dy;
                this.lastMousePos = { x, y };
                this.render();
            };

            const stopDrag = (x, y) => {
                // Si no se movió significativamente, es un click para posicionar cursor
                if (!isMoving && x !== undefined) {
                    this.setCursor(x, y);
                    this.mobileInput.focus(); 
                }
                this.isDragging = false;
            };

            // Listeners de Mouse
            this.canvas.addEventListener('mousedown', (e) => {
                if (e.button === 0) startDrag(e.clientX, e.clientY);
            });
            window.addEventListener('mousemove', (e) => moveDrag(e.clientX, e.clientY));
            window.addEventListener('mouseup', (e) => stopDrag(e.clientX, e.clientY));

            // Listeners Táctiles
            this.canvas.addEventListener('touchstart', (e) => {
                const touch = e.touches[0];
                startDrag(touch.clientX, touch.clientY);
            }, { passive: false });

            this.canvas.addEventListener('touchmove', (e) => {
                const touch = e.touches[0];
                moveDrag(touch.clientX, touch.clientY);
                e.preventDefault();
            }, { passive: false });

            this.canvas.addEventListener('touchend', (e) => {
                const touch = e.changedTouches[0];
                stopDrag(touch.clientX, touch.clientY);
            });

            // GESTIÓN DE ENTRADA DE TEXTO (Anti-doble letra)
            window.addEventListener('keydown', (e) => {
                if (e.ctrlKey || e.altKey || e.metaKey) return;
                
                // Solo procesamos teclas de navegación/borrado que 'input' no captura bien
                if (e.key === "Enter" || e.key === "Backspace") {
                    this.handleInput(e.key);
                }
            });

            this.mobileInput.addEventListener('input', (e) => {
                const char = e.data; 
                if (char) {
                    // Procesamos cada caracter (por si se pega texto)
                    for (let c of char) {
                        this.handleInput(c);
                    }
                } else if (e.inputType === "deleteContentBackward") {
                    // Fallback para borrado en algunos navegadores móviles
                    this.handleInput("Backspace");
                }
                this.mobileInput.value = ""; 
            });
        }

        setCursor(clientX, clientY) {
            this.cursor.x = Math.floor(clientX / this.cellW + this.offset.x);
            this.cursor.y = Math.floor(clientY / this.cellH + this.offset.y);
            this.render();
        }

        handleInput(key) {
            if (key === "Enter") {
                this.cursor.y++;
                this.cursor.x = Math.floor(this.cursor.x); 
            } else if (key === "Backspace") {
                this.cursor.x--;
                this.saveChar(this.cursor.x, this.cursor.y, null);
            } else if (key.length === 1) {
                this.saveChar(this.cursor.x, this.cursor.y, key);
                this.cursor.x++;
            }
            this.render();
        }

        saveChar(x, y, char) {
            const id = `${x}_${y}`;
            set(ref(db, `canvas_content/${id}`), char);
        }

        render() {
            this.ctx.fillStyle = "#FFFED7"; 
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

            this.ctx.fillStyle = "#000";
            this.ctx.font = `${FONT_SIZE}px ${FONT_FACE}`;
            this.ctx.textBaseline = "top";
            
            for (const [coord, char] of Object.entries(this.content)) {
                if (!char) continue;
                const [x, y] = coord.split('_').map(Number);
                const drawX = (x - this.offset.x) * this.cellW;
                const drawY = (y - this.offset.y) * this.cellH;
                
                if (drawX > -this.cellW && drawX < this.canvas.width && 
                    drawY > -this.cellH && drawY < this.canvas.height) {
                    this.ctx.fillText(char, drawX, drawY);
                }
            }

            // Cursor visual
            this.ctx.fillStyle = "rgba(0, 0, 0, 0.12)";
            this.ctx.fillRect(
                (this.cursor.x - this.offset.x) * this.cellW, 
                (this.cursor.y - this.offset.y) * this.cellH, 
                this.cellW, this.cellH
            );
        }
    }

    new Guestbook();
</script>
</body>
</html>